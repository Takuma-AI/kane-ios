WEBVTT

00:00.000 --> 00:29.260
Hello everyone. Thank you very much for having me. It's a very exciting place to be, very

00:29.260 --> 00:37.900
exciting time to be. I mean, this has been a pretty intense couple of days. I don't know if you

00:37.900 --> 00:43.900
feel the same way, but also very energizing. So I want to take a little bit of your time today to

00:43.900 --> 00:49.180
talk about what I see is the coming of the new code, in particular specifications, which sort of

00:49.180 --> 00:55.100
hold this promise that it has been the dream of the industry where you can write your code, your

00:55.100 --> 01:02.060
intentions once, and run them everywhere. A quick intro. My name is Sean. I work at OpenAI,

01:02.060 --> 01:07.260
specifically in alignment research. And today I want to talk about sort of the value of code versus

01:07.260 --> 01:12.140
communication. And why specifications might be a little bit of a better approach in general.

01:15.580 --> 01:21.580
I'm going to go over the anatomy of a specification, and we'll use the model spec as the example.

01:22.540 --> 01:28.860
And we'll talk about communicating intents to other humans, and we'll go over the 40sickofancy issue

01:29.500 --> 01:36.780
as a case study. We'll talk about how to make the specification executable, how to communicate

01:36.780 --> 01:42.780
intents to the models, and how to think about specifications as code, even if they're a little

01:42.780 --> 01:49.180
bit different. And we'll end on a couple of open questions. So let's talk about code versus

01:49.180 --> 01:55.340
communication. Real quick, raise your hand if you write code and vibe code counts.

01:56.940 --> 02:06.220
Cool, keep them up if your job is to write code. Okay, now for those people, keep your hand up if

02:06.220 --> 02:14.220
you feel that the most valuable professional artifact that you produce is code. Okay, there's

02:14.220 --> 02:20.620
quite a few people, and I think this is quite natural. We all work very, very hard to solve problems.

02:20.620 --> 02:25.740
We talk with people, we gather requirements, we think through implementation details, we integrate

02:25.740 --> 02:31.740
with lots of different sources, and the ultimate thing that we produce is code. Code is the

02:31.740 --> 02:38.540
artifact that we can point to, we can measure, we can debate, and we can discuss. It feels tangible

02:38.540 --> 02:45.900
and real, but it's sort of underselling the job that each of you does. Code is sort of 10 to 20

02:45.900 --> 02:52.300
percent of the value that you bring. The other 80 to 90 percent is in structured communication.

02:53.100 --> 02:56.780
And this is going to be different for everyone, but a process typically looks something like

02:56.780 --> 03:03.420
you talk to users in order to understand their challenges. You distill these stories down,

03:03.500 --> 03:08.540
and then ideate about how to solve these problems. What is the goal that you want to achieve?

03:09.580 --> 03:14.860
You plan ways to achieve those goals. You share those plans with your colleagues.

03:16.540 --> 03:20.940
You translate those plans into code. So this is a very important step, obviously.

03:21.900 --> 03:28.380
And then you test and verify, not the code itself. Right, no one cares actually about the code itself.

03:28.380 --> 03:35.260
What you care is when the code ran, did it achieve the goals, did it alleviate the challenges

03:35.260 --> 03:43.100
of your user? You look at the effects that your code had on the world. So talking, understanding,

03:43.740 --> 03:53.020
distilling, ideating, planning, sharing, translating, testing, verifying, these all sound like

03:53.020 --> 03:59.580
structured communication to me. And structured communication is the bottleneck,

04:00.700 --> 04:06.380
knowing what to build, talking to people, and gathering requirements, knowing how to build it,

04:06.380 --> 04:11.180
knowing why to build it. And at the end of the day, knowing if it has been built correctly and

04:11.180 --> 04:18.620
has actually achieved the intentions that you set out with. And the more advanced AI models get,

04:18.620 --> 04:25.340
the more we are all going to starkly feel this bottleneck. Because in the near future,

04:25.340 --> 04:32.940
the person who communicates most effectively is the most valuable programmer. And literally,

04:32.940 --> 04:39.420
if you can communicate effectively, you can program. So let's take a vibe coding as an

04:39.420 --> 04:45.420
illustrative example. Vibe coding tends to feel quite good. And it's worth asking why is that?

04:46.380 --> 04:51.980
Vibe coding is fundamentally about communication first, and the code is actually a secondary

04:51.980 --> 04:58.540
downstream artifact of that communication. We get to describe our intentions and the outcomes

04:58.540 --> 05:04.300
that we want to see, and we let the model actually handle the grunt work for us. And even so,

05:04.300 --> 05:10.700
there is something strange about the way that we do vibe coding. We communicate via prompts to the

05:10.700 --> 05:17.980
model. And we tell them our intentions and our values. And we get a code artifact out at the end.

05:18.860 --> 05:26.140
And then we sort of throw our prompts away. They're ephemeral. And if you've written TypeScript or

05:26.140 --> 05:34.060
Rust, once you put your code through a compiler, or it gets down into a binary, no one is happy with

05:34.060 --> 05:39.900
that binary. That wasn't the purpose. It's useful. In fact, we always regenerate the

05:39.900 --> 05:45.500
binary from scratch every time we compile, or we run our code through V8, or whatever might be,

05:45.500 --> 05:52.780
from the source spec. It's the source specification. That's the valuable artifact. And yet when we

05:52.780 --> 05:57.740
prompt elements, we sort of do the opposite. We keep the generated code, and we delete the prompt.

05:58.300 --> 06:02.220
And this feels like a little bit like you shred the source, and then you very carefully version

06:02.220 --> 06:10.460
control the binary. And that's why it's so important to actually capture the intent and the values

06:10.460 --> 06:17.020
in a specification. A written specification is what enables you to align humans on the shared

06:17.020 --> 06:22.140
set of goals, and to know if you are aligned, if you are actually synchronized on what needs to be

06:22.140 --> 06:27.180
done. This is the artifact that you discuss, that you debate, that you refer to, and that you

06:27.180 --> 06:32.860
synchronize on. And this is really important, so I want to nail this home, that a written

06:32.860 --> 06:41.020
specification effectively aligns humans. And it is the artifact that you use to communicate,

06:41.020 --> 06:46.940
and to discuss, and debate, and refer to, and synchronize on. If you don't have a specification,

06:46.940 --> 06:53.980
you just have a vague idea. Now let's talk about why specifications are more powerful in general

06:53.980 --> 07:00.620
than code. Because code itself is actually a lossy projection from the specification.

07:01.740 --> 07:07.660
In the same way that if you were to take a compiled C binary and decompile it, you wouldn't get

07:07.660 --> 07:13.020
nice comments and well-named variables, you would have to work backwards, you'd have to infer

07:13.020 --> 07:17.980
what was this person trying to do? Why is this code written this way? It isn't actually contained

07:17.980 --> 07:24.140
in there. It was a lossy translation. In the same way, code itself, even nice code, typically

07:24.140 --> 07:31.260
doesn't embody all of the intentions and the values in itself. You have to infer what is the

07:31.260 --> 07:38.220
ultimate goal that this team is trying to achieve when you read through code. So communication,

07:38.220 --> 07:43.420
the work that we establish, we already do, when embodied inside of a written specification,

07:43.420 --> 07:49.420
is better than code. It actually encodes all of the necessary requirements in order to generate

07:49.420 --> 07:55.900
the code. And in the same way that having a source code that you passed to a compiler allows you

07:55.900 --> 08:03.820
to target multiple different architectures. You can compile for ARM64, X86, or WebAssembly.

08:03.820 --> 08:09.900
The source document actually contains enough information to describe how to translate it to your

08:09.900 --> 08:18.940
target architecture. In the same way, a sufficiently robust specification given to models will produce

08:19.580 --> 08:26.700
good typescript, good rust, servers, clients, documentation, tutorials, blog posts, and even podcasts.

08:28.220 --> 08:32.220
Show of hands, who works at a company that has developers as customers?

08:32.220 --> 08:40.780
Okay, so a quick like thought exercises, if you were to take your entire code base, all of the

08:40.780 --> 08:45.900
documentation, all of the code that runs your business, and you were to put that into a podcast

08:45.900 --> 08:50.780
generator, could you generate something that would be sufficiently interesting and compelling that

08:50.780 --> 08:56.700
would tell the users how to succeed, how to achieve their goals, or as all of that information

08:56.700 --> 09:03.980
somewhere else. It's not actually in your code. And so moving forward, the new scare skill

09:03.980 --> 09:11.100
is writing specifications that fully capture the intent and values. And whoever masters that,

09:11.100 --> 09:17.340
again, becomes the most valuable programmer. And there's a reasonable chance that this is going

09:17.340 --> 09:23.340
to be the coders of today. This is already very similar to what we do. However, product managers

09:23.340 --> 09:29.740
also write specifications, lawmakers write legal specifications. This is actually a universal

09:29.740 --> 09:34.140
principle. So with that in mind, let's look at what a specification actually looks like.

09:35.020 --> 09:40.460
And I'm going to use the OpenAI model spec as an example here. So last year, OpenAI released

09:40.460 --> 09:48.140
the model spec. And this is a living document that tries to clearly and unambiguously express

09:48.140 --> 09:53.980
the intentions and values that OpenAI hopes to imbue its models with that it ships to the world.

09:56.860 --> 10:03.180
And it was updated in February and open sourced. So you can actually go to GitHub and you can see the

10:03.180 --> 10:09.260
implementation of the model spec. And surprise, surprise, it's actually just a collection of

10:09.260 --> 10:16.780
markdown files. Just looks like this. Now, markdown is remarkable. It is human readable. It's

10:16.780 --> 10:23.660
versioned. It's changed logged. And because it is natural language, everyone, not just technical

10:23.660 --> 10:30.140
people, can contribute, including product, legal, safety, research, policy, they can all read,

10:30.140 --> 10:37.660
discuss, debate, and contribute to the same source code. This is the universal artifact that

10:37.660 --> 10:43.020
aligns all of the humans as to our intentions and values inside of the company.

10:43.020 --> 10:50.540
Now, as much as we might try to use unambiguous language, there are times where it's very difficult

10:50.540 --> 10:57.420
to express the nuance. So every clause in the model spec has an ID here. So you can see

10:57.420 --> 11:05.180
SY73 here. And using that ID, you can find another file in the repository, SY73.markdown,

11:05.180 --> 11:14.380
or MD, that contains one or more challenging prompts for this exact clause. So the document itself

11:14.380 --> 11:21.980
actually encodes success criteria. That the model under test has to be able to answer this in a

11:21.980 --> 11:32.220
way that actually adheres to that clause. So let's talk about sycophantcy. Recently, there was

11:32.220 --> 11:38.460
a update to 4.0. I don't know if you've heard of this. They're caused extreme sycophantcy.

11:40.300 --> 11:48.860
And we can ask what value is the model spec in this scenario? And the model spec serves to align

11:48.860 --> 11:56.060
humans around a set of values and intentions. Here's an example of sycophantcy where the user calls

11:56.060 --> 12:03.500
out the behavior being sycophant, or sycophantic, at the expense of impartial truth, and the model

12:03.500 --> 12:11.740
very kindly praises the user for their insight. There have been other esteemed researchers who have

12:11.740 --> 12:26.300
found similarly concerning examples. And this hurts. Shipping sycophantcy, in this matter,

12:26.300 --> 12:35.740
erodes trust. It hurts. And it also raises a lot of questions. Like, was this intentional?

12:35.740 --> 12:41.100
You can see some way where you might interpret it that way. Was it accidental? And how I wasn't

12:41.100 --> 12:49.900
caught? Luckily, the model spec actually includes a section dedicated to this since its release that says

12:49.900 --> 12:55.900
don't be sycophantic. And it explains that while sycophantcy might feel good in the short term,

12:55.900 --> 13:01.180
it's bad for everyone in the long term. So we actually expressed our intentions and our values,

13:01.180 --> 13:10.700
and we're able to communicate it to others through this. So people could reference it. And if we

13:11.100 --> 13:16.860
have it in the model specification, if the model specification is our agreed upon set of intentions

13:16.860 --> 13:24.940
and values, and the behavior doesn't align with that, then this must be a bug. So we rolled back,

13:24.940 --> 13:28.060
we published some studies and some blog posts, and we fixed it.

13:31.420 --> 13:37.420
But in the interim, the spec served as a trust anchor, a way to communicate to people what is

13:37.420 --> 13:48.700
expected and what is not expected. So if the only thing the model specification did was to align

13:48.700 --> 13:55.020
humans along those shared sets of intentions and values, it would already be incredibly useful.

13:56.620 --> 14:02.380
But ideally, we can also align our models and the artifacts that our models produce against

14:02.380 --> 14:07.900
that same specification. So there's a technique, a paper that we released called Deliberative

14:07.900 --> 14:12.860
Alignment, that sort of talks about this, how to automatically align a model. And the technique

14:12.860 --> 14:19.740
is such where you take your specification and set a very challenging input prompts, and you

14:19.740 --> 14:25.980
sample from the model under a test or training. You then take its response, the original prompt,

14:25.980 --> 14:30.620
and the policy, and you give that to a greater model, and you ask it to score the response

14:30.620 --> 14:37.100
according to the specification. How aligned is it? So the document actually becomes both training

14:37.100 --> 14:44.060
material and eval material. And based off of the score, we reinforce those weights. And it goes

14:44.060 --> 14:48.940
from, you know, you could include your specification in the context, in the maybe system message,

14:48.940 --> 14:52.460
or development message, in every single time you sample. And that is actually quite useful.

14:52.460 --> 14:58.540
A prompted model is going to be somewhat aligned. But it does detract for the compute available to

14:58.540 --> 15:04.220
solve the problem that you're trying to solve with the model. And keep in mind, these specifications

15:04.220 --> 15:09.980
can be anything. They could be code style, or testing requirements, or safety requirements.

15:09.980 --> 15:14.540
All of that can be embedded into the model. So through this technique, you're actually moving it

15:14.540 --> 15:20.380
from an inference time compute, and actually you're pushing down into the weights of the model,

15:20.380 --> 15:27.020
so that the model actually feels your policy and is able to sort of muscle memory style apply it

15:27.020 --> 15:32.540
to the problem at hand. And even though we saw that the model spec is just markdown,

15:33.180 --> 15:38.780
it's quite useful to think of it as code. It's quite analogous. These specifications that

15:38.780 --> 15:44.380
compose, they're executable, as we've seen, they are testable. They have interfaces where they

15:44.380 --> 15:52.460
touch the real world. They can be shipped as modules. And whenever you're working on a model spec,

15:52.460 --> 15:57.500
there are a lot of similar sort of problem domains. So just like in programming, where you have a

15:57.500 --> 16:02.940
type checker, the type checker is meant to ensure consistency, where if interface A has a dependent

16:04.060 --> 16:08.380
module will be, they have to be consistent in their understanding of one another. So if

16:09.180 --> 16:13.340
department A writes a spec, and department B writes a spec, and there is a conflict in there,

16:13.340 --> 16:18.700
you want to be able to pull that forward and maybe block the publication of the specification.

16:19.580 --> 16:24.620
As we saw, the policy can actually embody its own unit tests. And you can imagine various

16:24.620 --> 16:28.620
linters, where if you're using overly ambiguous language, you're going to confuse humans,

16:28.620 --> 16:32.780
and you're going to confuse the model, and the artifacts you get from that are going to be less

16:32.780 --> 16:39.020
satisfactory. So specs actually give us a very similar tool chain, but it's targeted at

16:39.020 --> 16:45.340
intentions rather than syntax. So let's talk about lawmakers as programmers.

16:46.300 --> 16:54.300
The U.S. Constitution is literally a national model specification. It has written text,

16:54.300 --> 16:59.740
which is aspirationally, at least clear and unambiguous policy, that we can all refer to.

17:00.460 --> 17:05.020
And it doesn't mean that we agree with it, but we can refer to it as the current status quo,

17:05.020 --> 17:13.020
as the reality. There is a version way to make amendments, to bump, and to publish updates to it.

17:13.820 --> 17:20.460
There is judicial review, where a grader is effectively grading a situation and seeing

17:20.460 --> 17:28.780
how well it aligns with the policy. And even though the source policy is meant to be unambiguous,

17:28.780 --> 17:33.180
sometimes you don't, the world is messy, and maybe you miss part of the distribution,

17:33.180 --> 17:39.900
and a case falls through. And in that case, there is a lot of compute spent in judicial review,

17:39.900 --> 17:44.460
where you're trying to understand how the law actually applies here. And once that's decided,

17:44.460 --> 17:50.140
it sets a precedent. And that precedent is effectively an input, output pair that serves as a unit

17:50.140 --> 17:57.020
test that disambiguates and reinforces the original policy spec. It has things like a chain of

17:57.020 --> 18:02.860
command embedded in it, and the enforcement of this over time is a training loop that helps

18:02.860 --> 18:09.580
align all of us towards a shared set of intentions and values. So this is one artifact that

18:09.580 --> 18:14.940
communicates intent. It adjudicates compliance, and it has a way of evolving safely.

18:17.420 --> 18:22.300
So it's quite possible that lawmakers will be programmers, or inversely that programmers

18:22.300 --> 18:29.500
will be lawmakers in the future. And actually, this apply, this is a very universal concept.

18:29.500 --> 18:35.900
Programmers are in the business of aligning silicon via code specifications. Product managers

18:35.900 --> 18:42.140
align teams via product specifications. Lawmakers literally align humans via legal specifications.

18:42.780 --> 18:47.260
And everyone in this room, whenever you are doing a prompt, it's a sort of proto-specification.

18:47.820 --> 18:54.700
You are in the business of aligning AI models towards a command set of intentions and values,

18:55.260 --> 19:02.220
and whether you realize that you are spec authors in this world. And specs let you ship faster

19:02.220 --> 19:13.100
and safer. Everyone can contribute, and whoever writes the spec, be it a PM, a lawmaker, an engineer,

19:13.100 --> 19:21.100
a marketer, is now the programmer. And software engineering has never been about code. Going

19:21.100 --> 19:25.420
back to our original question, a lot of you put your hands down when you thought, well, actually,

19:25.420 --> 19:30.380
the thing I produced is not code. Engineering has never been about this. Coding is an incredible

19:30.380 --> 19:36.060
skill and a wonderful asset, but it is not the end goal. Engineering is the precise exploration by

19:36.060 --> 19:42.140
humans of software solutions to human problems. It's always been this way. We're just moving away

19:42.140 --> 19:48.940
from sort of the disparate machine encodings to a unified human encoding of how we actually solve

19:48.940 --> 19:55.580
these problems. I want to thank Josh for this credit. So I want to ask you, put this in action.

19:56.460 --> 20:01.980
Whenever you're working on your next AI feature, start with the specification. What do you actually

20:01.980 --> 20:07.500
expect to happen? What success criteria look like? Debate, whether or not it's actually clearly

20:07.500 --> 20:11.980
written down and communicated. Make the spec executable. Feed the spec to the model,

20:14.300 --> 20:20.140
and test against the model, or test against the spec. And there's an interesting question

20:20.220 --> 20:27.580
in this world, given that there's so many parallels between programming and spec authorship. I wonder

20:27.580 --> 20:34.140
what is the IDE look like in the future? An integrated development environment. I like to think

20:34.140 --> 20:39.580
it's something like an integrated thought clarifier. Whenever you're writing your specification,

20:39.580 --> 20:46.460
it sort of pulls out the ambiguity and asks you to clarify it, and it really clarifies your

20:46.460 --> 20:51.980
thoughts so that you and all human beings can communicate your intent to each other much more

20:51.980 --> 21:00.300
effectively and to the models. I have a closing request for help, which is what is both a

21:00.300 --> 21:07.180
amenable and an investor need of a specification? This is a lining agent at scale. I love this line

21:07.180 --> 21:12.460
of like, then you realize that you never told it what you wanted, and maybe you never fully understood

21:12.460 --> 21:17.980
it anyway. This is a cry for specification. We have a new agent robustness team that we've started

21:17.980 --> 21:23.340
up, so please join us and help us deliver safe, safe AGI for the benefit of all humanity.

21:25.180 --> 21:27.180
And thank you. I'm happy to chat.

